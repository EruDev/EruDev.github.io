[{"title":"2020, 这一年","date":"2020-12-28T12:19:13.000Z","path":"2020/12/28/2020，这一年/","text":"所有事到最后都会是好事如果还不是那它就还没到最后 杂谈2020 与我而言，是本命年。回头想想去年这个时候，我应该在疯狂加班吧。记得基本上每天都是坐最后一班地铁回去的，应该说是前东家了，因为没有产品的原因，导致需求很不明确，有时候反反复复改好几遍。到现在已经入职新东家快一个月了，在北京三年唯一一家不加班的公司。 年初突然袭来的疫情让大多数公司实施了远程办公，我是没想到前东家也能远程办公，而且效率比在公司要高的多。以后如果可以我也想在家远程办公了，个人觉得在家跟在公司都差不多，主要是时间管理。 今年发生了好多事，家里面老爸买了辆货车，帮地方上的企业、公司拉货，现在看来还不错，是在给自己打工了，看得出来老爸比之前开心多了，虽然很累，每天都三四点就起来了，晚上到七八点甚至更晚才回家。 理财记得二月份的时候，美股熔断了四五次，巴菲特说自己活这么久都没见过。我是去年 11 月份跟着同学入的坑，那时候刚开始在蚂蚁财富上跟着买基金，赚了大概几百块钱，不敢投多的。然后到了三月份，不知道咋的脑子一热，跟着同学一起梭哈了科技了，结果当然是被毒打了，套在了山顶了。就一直套到了七月份，也一直没割，后面想必大家也知道了，七月都说牛市了，行情变好了，然后我跟同学也开了户，开始入坑炒股，七月份当然随便买啥都是赚的，赚了点小钱。后面八月开始到现在，接受了股市的毒打，好在还没亏本。半年下来，就是认知以外的钱真的不好赚。 工作在年初的时候我就换工作的打算，所以这一年还是花了比较多的时间在学习上面。主要还是面向面试学习，并发方面看了极客时间的 Java并发编程实战，书籍 Java 并发实战，Java并发编程的艺术。这里还推荐一本偏实战的书 Java多线程编程实战指南(核心篇)。JVM 自然是周志明大佬写的 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）。MySQL 是看的掘金小册小孩在写的 MySQL 是怎样运行的：从根儿上理解 MySQL，对了小孩在还出了一本同名的书，也可以看看。搞 Java 的始终都绕不开 Spring，书籍方面推荐 Spring 源码解析第二版，极客时间小马哥出的两门 Spring 的课。 20212020 的话，要做这么几件事情： 继续精进后端 学习理财知识。 锻炼身体，一周跑步两次(其实今年已经开始重新跑步了，无奈冬天太冷了，就一直没出去跑)。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://yoursite.com/tags/年终总结/"}]},{"title":"动手实现LinkedList","date":"2020-06-20T01:09:33.000Z","path":"2020/06/20/动手实现LinkedList/","text":"变秃变强 问题 平时大家都在说 ArrayList 查找快，增删慢；LinkedList 查找慢，增删快，但是为什么呢？ LinkedList 底层实现，如果让你实现一个简单的 LinkedList，你会怎么实现？ 大家都知道 LinkedList 底层是双向链表，那么你觉得适用于哪些场景？ 分析源码首先还是想来看类注释，总结出以下几点： 双向链表实现了 List 和 Deque 接口，实现了所有可选的 List 操作，允许元素为 null； 是线程不安全的，List list = Collections.synchronizedList(new LinkedList(...)) 来实现线程安全； 不能保证迭代器的 fail-fast 行为，在不同步的并发情况下，不可能做出严格的保证。fail-fast 仅应用于检测错误。 整体结构 双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 链表中的元素叫 Node，可以看下源码中的实现： 1234567891011121314private static class Node&lt;E&gt; &#123; // 存储的数据 E item; // 指向下一个节点 Node&lt;E&gt; next; // 指向的前一个节点 Node&lt;E&gt; prev; // 构造方法，初始化参数 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 从头部新增12345678910111213141516private void linkFirst(E e) &#123; // 头结点引用 final Node&lt;E&gt; f = first; // 创建新增的节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 因为是加到头部，所以新增的就是新的头节点 first = newNode; // 如果头结点为空，那么表示头尾节点是同一个，都是 null if (f == null) last = newNode; else // 头结点的上一个节点指向新节点 f.prev = newNode; size++; modCount++;&#125; 查找尾部追加跟头部新增类似，这里就不再讲了。我觉得链表中实现的二分查找的思想，我们是可以借鉴的。 12345678910111213141516Node&lt;E&gt; node(int index) &#123; // index 需要查找的下标 // assert isElementIndex(index); // size &gt;&gt; 1 = size / 2，如果 index 处于队列的前半部分，那么从头节点开始往后找 // 反之从尾结点开始 向前找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 删除 以删除对应下标的 Node 为例 12345678910111213141516171819202122232425262728293031323334353637public E remove(int index) &#123; // 检查索引是否在队列中 checkElementIndex(index); // 根据索引找到对应的 Node return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // 当前删除Node的值 final E element = x.item; // 当前Node的下一个节点 final Node&lt;E&gt; next = x.next; // 当前Node的前一个节点 final Node&lt;E&gt; prev = x.prev; // 如果前一个节点为null，说明当前节点就是头节点，那么把头节点设置为当前节点的下一个节点 // 反之，前一个节点的下一个节点指向当前节点的下一个节点 if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; // 如果尾结点为 null，说明当前节点就是尾结点，那么把尾结点设置为当前节点的前一个节点 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 迭代器因为 LinkedList 需要实现双向的访问，Iterator 满足不了。因为 Iterator 只能从前往后遍历，Java 提供了一个新的接口 ListIterator，提供了向前和向后迭代的方法： 迭代顺序 方法 从前往后迭代的方法 hasNext()、next()、nextIndex() 从后往前迭代的方法 previous()、previousIndex()、hasPrevious() 其实我看了下 ArrayList 也是有实现 ListIterator 接口的，只不过平时没用到，例如我们也可以从前往后查找： 1234567891011public void testListIterator()&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); ListIterator&lt;String&gt; listIterator = list.listIterator(2); while (listIterator.hasPrevious())&#123; String previous = listIterator.previous(); System.out.println(previous); &#125;&#125; LinkedList 里的 ListIterator 实现： 123456789101112131415161718private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned = null; // 迭代过程中上一次返回的Node private Node&lt;E&gt; next; // 下一个Node private int nextIndex; // 下一个索引 private int expectedModCount = modCount; public E next() &#123; // 检查版本号是否有误 checkForComodification(); // 二次检查，是否还有下一个Node if (!hasNext()) throw new NoSuchElementException(); // 第一次迭代的时候上一次返回值等于next节点 lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125;&#125; 好的，现在可以回答文中前面几个问题了。 ArrayList 底层是数组，LinkedList 底层是双向链表 对于插入 (add) 和 remove (删除)，ArrayList 需要移动目标节点后面的节点 ，System.arraycopy 用来移动节点(native方法)。而 LinkedList 只需要修改目标节点对应的 next 或 prev 属性即可。 对于查找操作，因为 ArrayList 是拿数组存的，所以直接根据索引就能取到对应的数据。而 LinkedList 需要从前往后或者从后往前迭代，查找目标数据 PS：对于顺序插入，也就是 ArrayList 不需要扩容，并且是最后一个节点插入，那么就不需要移动节点，因此效率上也不会比 LinkedList 差 最后附上自己实现的 LinkedList 代码地址","tags":[{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"动手实现ArrayList","date":"2020-04-05T05:28:39.000Z","path":"2020/04/05/动手实现ArrayList/","text":"纸上学来终究浅，只有自己实操了才能理解的更深刻 问题平时工作中 ArrayList 经常会用到，但是没细想底层实现原理。比如这里抛出几个问题： 添加、删除元素的时候，具体是怎么实现的？ 初始化的时候数组大小是多少，扩容机制？ 如果让你来实现的话，你会怎么做？ 分析源码看源码，首先要看类注释，我们看看类注释上面都说了什么，如下： 允许 put null 值，会自动扩容 size、isEmpty、get、set、add等方法时间复杂度都是O(1) 是非线程安全的，多线程情况下，推荐使用线程安全类： Collections#syschronizedList 增强 for 循环，或者使用迭代器迭代过程中，如果数字组大小被改线，会 fastfail (快速失败)，抛出异常 add(int index，E element)12345678910111213/*** 在指定的位置插入元素*/public void add(int index, E element) &#123; // 添加元素前 检查，指定下标不能为 0 ，不能大于数组长度 rangeCheckForAdd(index); // 检查数组是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 核心是 System.arraycopy(elementData, index, elementData, index + 1,size - index); 上面是思路，比如在下标为 1 也就是 b 的位置插入 d，那么起始的位置下标就是 1，目标位置下标就是起始位置+1，需要移动的步数就是数组的长度减去起始位置的下标。类似的删除也是同样的逻辑，只不过删除操作，会把最后一个元素置为 null，等待GC来清理。 ensureCapacityInternal(int minCapacity)我们来看下 ensureCapacityInternal 源码： 1234567891011121314151617181920212223242526272829303132private void ensureCapacityInternal(int minCapacity) &#123; //如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //确保容积足够 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //记录数组被修改 modCount++; // 如果我们期望的最小容量大于目前数组的长度，那么就扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;//扩容，并把现有数据拷贝到新的数组里面去private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 通过复制进行扩容 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 另外一点，ArrayList 无参构造器初始化时，默认大小是空数组，并不是10,10是在第一次 add 的时候扩容的数组值。 动手简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142** * 简单实现ArrayList * Created by eru on 2020/4/4. */public class MyList&lt;T&gt; &#123; /** * 数组长度 */ private int size; /** * 存储元素的数组 */ private Object[] myList; /*** * 默认初始化的为空的数组 */ private static final Object[] DEFAULT_EMPTY_LIST = &#123;&#125;; public MyList() &#123; myList = DEFAULT_EMPTY_LIST; &#125; /** * 构造指定大小的数组 * @param capacity 容量 */ public MyList(int capacity) &#123; if (capacity == 0)&#123; myList = DEFAULT_EMPTY_LIST; &#125;else if (capacity &gt; 0)&#123; myList = new Object[capacity]; &#125;else&#123; throw new RuntimeException(\"myList init capacity must more than 0\"); &#125; &#125; /** * 添加一个元素 * @param e 元素 * @return 成功与否 */ public boolean add(T e)&#123; // 1. 检查数组是否需要扩容 ensureCapacity(size + 1); // 2. 添加元素 myList[size++] = e; return true; &#125; /** * 检查是否需要扩容 * @param minCapacity 容量 */ private void ensureCapacity(int minCapacity) &#123; if (minCapacity - myList.length &gt; 0)&#123; int oldCapacity = myList.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0)&#123; newCapacity = minCapacity; &#125; myList = Arrays.copyOf(myList, newCapacity); &#125; &#125; /** * 数组长度 * @return 数组长度 */ public int length()&#123; return size; &#125; /** * 删除元素 * @param index 指定小标 * @return 被删除的元素 */ public T remove(int index)&#123; T oldValue = get(index); if (index == -1)&#123; throw new RuntimeException(\"该元素不存在\"); &#125; int numRemoved = size - index - 1; System.arraycopy(myList, index + 1, myList, index, numRemoved); myList[--size] = null; // 最后一位元素是需要删除的，等待GC回收 return oldValue; &#125; /** * 获取指定下标的元素 * @param index 下标 * @return 对应下标的元素 */ public T get(int index)&#123; return (T)myList[index]; &#125; /** * 用于测试，打印数组中所有的元素 */ public void printElement()&#123; StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i &lt; size; i++) &#123; sb.append(myList[i]); if (i != size - 1)&#123; sb.append(\",\"); &#125; &#125; sb.append(\"]\"); System.out.println(sb.toString()); &#125; /** * 指定下标 添加元素 * @param index 下标 * @param val 添加的元素 */ public void add(int index, T val)&#123; checkAdd(index); ensureCapacity(size + 1); System.arraycopy(myList, index, myList, index + 1, size - index); myList[index] = val; size++; &#125; /** * 添加指定元素的时候 做检验 * @param index 下标 */ private void checkAdd(int index) &#123; if (index &gt; size || index &lt; 0)&#123; throw new IndexOutOfBoundsException(\"Index: \" + index + \"Size: \" + size); &#125; &#125;&#125;","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"SpringBoot与缓存","date":"2020-03-07T09:14:10.000Z","path":"2020/03/07/SpringBoot与缓存/","text":"JSR-107、Spring缓存抽象、整合Redis 一、JSR-107Java Caching 定义了五个核心接口，分别是 CachingProvider，CacheManager，Cahe，Entry，Expiry。 CachingProvider定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期间访问多个 CachingProvider。 CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cahce 存在 CacheManager 的上下文。一个 CacheManager 仅被一个 CachingProdiver 所拥有。 Cache 是一个类似 map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 拥有。 Entry 是存储在 Cache 中的 key-value 对 Expiry 每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，条目为过期状态。一旦过期，条目不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy 设置。 二、Spring 缓存抽象Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合; Cache 接口下 Spring 提供了各种 xxxCache 的实现，如 RedisCache、EhCache，ConcurrentCache 等； 每次调用需要缓存功能的方法时，Spring 会检查指定参数的指定的目标方法是否已经被调用过；如果有就直接存缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户，下次调用直接从缓存中获取。 使用 Spring 缓存抽象时 我们需要关注两点： 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 三、几个重要概念、缓存注解 注解 描述 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存 @EnableCaching 开启基于缓存的注解 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 四、简单分析缓存原理 CacheAutoConfiguration会在启动时，注入存在的 CacheConfigration，默认采用的是 SimpleCacheConfiguration SimpleCacheConfiguration：cacheManager() 方法，可以看到会注入一个 ConcurrentMapCacheManager ConcurrentMapCacheManager: getCache() 是用 concurrentMap 来存储的，首次调用的时候，如果没有该数据，会调用createConcurrentMapCache @Cacheable： 方法运行之前，先去查询 Cache (缓存组件)，按照 cacheNames 指定的名字获取；CacheManager先获取相应的缓存，第一次获取缓存如果没有 Cache 组件自动创建 去 Cache 中查找缓存的内容，使用一个 key，默认就是方法的参数，key 是按照某种策略生成的，默认是keyGenerator生成的 没有查到缓存就调用目标方法 将目标方法返回的结果，放进缓存中","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot整合Mybatis-Plus","date":"2019-10-27T08:38:00.000Z","path":"2019/10/27/SpringBoot整合Mybatis-Plus/","text":"简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 快速入门定义 user表，表结构如下： id name age email manager_id create_time 1087982257332887553 大boss 40 boss@baomidou.com 2019-01-11 14:20:20 1088248166370832385 王天风 25 wtf@baomidou.com 1087982257332887553 2019-02-05 11:12:22 1088250446457389058 李艺伟 28 lyw@baomidou.com 1088248166370832385 2019-02-14 08:31:16 定义实体类 ： 1234567891011121314@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email; private Long managerId; private Date createTime;&#125; dao 接口，UserMapper，只需要继承 BaseMapper&lt;User&gt; 测试例子： 123456789101112131415@Slf4j@SpringBootTest@RunWith(SpringRunner.class)public class UserMapperTest &#123; @Autowired UserMapper userMapper; @Test public void testSelectAll()&#123; List&lt;User&gt; userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); &#125;&#125; 条件查询 名字包含雨并且年龄小于40 (name like ‘%雨%’ and age &lt; 40) 12345678@Test public void selectByWrapper()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(\"name\", \"雨\").lt(\"age\", 40); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 名字包含雨并且年龄大于等于20且小于等于40并且email不能为空 (name like ‘%雨%’ and age between 20 and 40 and email is not null) 1234567@Test public void selectByWrapper2()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(\"name\", \"雨\").between(\"age\", 20, 40).isNotNull(\"email\"); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 创建日期为2019/2/14并且直属上级名字为王姓 (date_formate(‘%Y-%M-%d’, date) and manager_id in (select manager_id from user where name like ‘王%’)) 12345678910@Test public void selectByWrapper4()&#123; Date date = new Date(2019, 2, 5); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper. apply(\"date_format(create_time,'%Y-%m-%d') = &#123;0&#125;\", \"2019-02-05\") .inSql(\"manager_id\", \"select manager_id from user where name like '王%'\"); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 按照直属上级分组，查询每组的平均年龄、最大年龄、最小年龄，并且只取年龄总和小于500的组 (select avg(age), max(age), min(age) from user group by manager_id having sum(age) &lt; 500) 123456789@Test public void selectByWrapper12()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(\"avg(age), max(age), min(age)\") .groupBy(\"manager_id\") .having(\"sum(age) &lt; &#123;0&#125;\", 500); List&lt;Map&lt;String, Object&gt;&gt; users = userMapper.selectMaps(queryWrapper); users.forEach(System.out::println); &#125; lambda 条件查询器 1234567@Test public void selectByWrapper13()&#123; LambdaQueryWrapper&lt;User&gt; lambdaQuery = Wrappers.lambdaQuery(); lambdaQuery.like(User::getName, \"雨\").lt(User::getAge, 40); List&lt;Map&lt;String, Object&gt;&gt; users = userMapper.selectMaps(lambdaQuery); users.forEach(System.out::println); &#125; 根据实体查询 123456789@Test public void selectByEntity()&#123; User user = new User(); user.setName(\"王天风\"); user.setAge(25); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(user); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125;","tags":[{"name":"Mybatis-Plus","slug":"Mybatis-Plus","permalink":"http://yoursite.com/tags/Mybatis-Plus/"}]},{"title":"SpringBoot整合Jpa","date":"2019-10-20T05:38:27.000Z","path":"2019/10/20/SpringBoot整合Jpa/","text":"表结构12345Hero Category Hero_Category------- ------- -------------id id hero_idname name cate_id superior 英雄表和分类表是多对多的关系，分类表里面的 superior为上级分类 id，superior 和 id 是一对多的关系。 实体对象1234567public class Hero &#123; @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinTable(name = \"orm_hero_cate\", joinColumns = @JoinColumn(name = \"hero_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"cate_id\", referencedColumnName = \"id\")) private List&lt;Category&gt; categories;&#125; 1234567891011public class Category &#123; @ManyToOne(cascade = &#123;CascadeType.REFRESH, CascadeType.REMOVE&#125;, optional = true) @JoinColumn(name = \"superior\", referencedColumnName = \"id\") private Category superior; @ManyToMany(mappedBy = \"categories\") private List&lt;Hero&gt; heroes; @OneToMany(mappedBy=\"superior\") private List&lt;Category&gt; children;&#125; 相关说明： @JoinTable，表示通过第三张关联表来管理 hero 和 category，joinColumn，关联到主表的外键名，主表名+下划线+主表中的主键列名，即 hero_id。关联到从表的外键名，主表中用于关联的属性名+下划线+从表的主键列名，即cate_id。 主表就是关系维护端对应的表，从表就是关系被维护端对应的表 superior 和 id 是一对多的关系，@ManyToOne来表示 mapperBy表示关联的属性字段 测试代码 1234567891011121314151617181920212223242526@Test public void testSave()&#123; List&lt;Category&gt; categoryList = categoryDao.findByLevel(0); if (categoryList.size() == 0)&#123; Category testCate = Category.builder().name(\"testCate\").level(1).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_1 = Category.builder().name(\"testCate_1\").level(2).superior(testCate).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_2 = Category.builder().name(\"testCate_2\").level(2).superior(testCate).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_1_1 = Category.builder().name(\"testCate_1_1\").level(3).superior(testCate_1).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); categoryList.add(testCate); categoryList.add(testCate_1); categoryList.add(testCate_2); categoryList.add(testCate_1_1); categoryDao.saveAll(categoryList); List&lt;Category&gt; categories = categoryDao.findAll(); log.debug(\"【分类】=&#123;&#125;\", JSONArray.toJSONString(categories)); &#125; heroDao.findById(1).ifPresent(hero -&gt; &#123; hero.setCategories(categoryList); hero.setName(\"添加分类\"); heroDao.save(hero); &#125;); log.debug(\"【英雄分类】=&#123;&#125;\", JSONUtil.toJsonStr(heroDao.findById(1).get().getCategories())); &#125; 参考https://stackoverflow.com/questions/5478328/jpa-jointable-annotation https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-orm-jpa","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]}]