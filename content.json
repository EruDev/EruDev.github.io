[{"title":"SpringBoot整合Jpa","date":"2019-10-20T05:38:27.000Z","path":"2019/10/20/SpringBoot整合Jpa/","text":"表结构12345Hero Category Hero_Category------- ------- -------------id id hero_idname name cate_id superior 英雄表和分类表是多对多的关系，分类表里面的 superior为上级分类 id，superior 和 id 是一对多的关系。 实体对象1234567public class Hero &#123; @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinTable(name = \"orm_hero_cate\", joinColumns = @JoinColumn(name = \"hero_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"cate_id\", referencedColumnName = \"id\")) private List&lt;Category&gt; categories;&#125; 1234567891011public class Category &#123; @ManyToOne(cascade = &#123;CascadeType.REFRESH, CascadeType.REMOVE&#125;, optional = true) @JoinColumn(name = \"superior\", referencedColumnName = \"id\") private Category superior; @ManyToMany(mappedBy = \"categories\") private List&lt;Hero&gt; heroes; @OneToMany(mappedBy=\"superior\") private List&lt;Category&gt; children;&#125; 相关说明： @JoinTable，表示通过第三张关联表来管理 hero 和 category，joinColumn，关联到主表的外键名，主表名+下划线+主表中的主键列名，即 hero_id。关联到从表的外键名，主表中用于关联的属性名+下划线+从表的主键列名，即cate_id。 主表就是关系维护端对应的表，从表就是关系被维护端对应的表 superior 和 id 是一对多的关系，@ManyToOne来表示 mapperBy表示关联的属性字段 测试代码 1234567891011121314151617181920212223242526@Test public void testSave()&#123; List&lt;Category&gt; categoryList = categoryDao.findByLevel(0); if (categoryList.size() == 0)&#123; Category testCate = Category.builder().name(\"testCate\").level(1).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_1 = Category.builder().name(\"testCate_1\").level(2).superior(testCate).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_2 = Category.builder().name(\"testCate_2\").level(2).superior(testCate).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_1_1 = Category.builder().name(\"testCate_1_1\").level(3).superior(testCate_1).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); categoryList.add(testCate); categoryList.add(testCate_1); categoryList.add(testCate_2); categoryList.add(testCate_1_1); categoryDao.saveAll(categoryList); List&lt;Category&gt; categories = categoryDao.findAll(); log.debug(\"【分类】=&#123;&#125;\", JSONArray.toJSONString(categories)); &#125; heroDao.findById(1).ifPresent(hero -&gt; &#123; hero.setCategories(categoryList); hero.setName(\"添加分类\"); heroDao.save(hero); &#125;); log.debug(\"【英雄分类】=&#123;&#125;\", JSONUtil.toJsonStr(heroDao.findById(1).get().getCategories())); &#125; 参考https://stackoverflow.com/questions/5478328/jpa-jointable-annotation https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-orm-jpa","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]}]