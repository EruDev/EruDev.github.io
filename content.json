[{"title":"SpringBoot与缓存","date":"2020-03-07T09:14:10.000Z","path":"2020/03/07/SpringBoot与缓存/","text":"JSR-107、Spring缓存抽象、整合Redis 一、JSR-107Java Caching 定义了五个核心接口，分别是 CachingProvider，CacheManager，Cahe，Entry，Expiry。 CachingProvider定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期间访问多个 CachingProvider。 CacheManager 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cahce 存在 CacheManager 的上下文。一个 CacheManager 仅被一个 CachingProdiver 所拥有。 Cache 是一个类似 map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 拥有。 Entry 是存储在 Cache 中的 key-value 对 Expiry 每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，条目为过期状态。一旦过期，条目不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy 设置。 二、Spring 缓存抽象Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合; Cache 接口下 Spring 提供了各种 xxxCache 的实现，如 RedisCache、EhCache，ConcurrentCache 等； 每次调用需要缓存功能的方法时，Spring 会检查指定参数的指定的目标方法是否已经被调用过；如果有就直接存缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户，下次调用直接从缓存中获取。 使用 Spring 缓存抽象时 我们需要关注两点： 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 三、几个重要概念、缓存注解 注解 描述 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存 @EnableCaching 开启基于缓存的注解 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 四、简单分析缓存原理 CacheAutoConfiguration会在启动时，注入存在的 CacheConfigration，默认采用的是 SimpleCacheConfiguration SimpleCacheConfiguration：cacheManager() 方法，可以看到会注入一个 ConcurrentMapCacheManager ConcurrentMapCacheManager: getCache() 是用 concurrentMap 来存储的，首次调用的时候，如果没有该数据，会调用createConcurrentMapCache @Cacheable： 方法运行之前，先去查询 Cache (缓存组件)，按照 cacheNames 指定的名字获取；CacheManager先获取相应的缓存，第一次获取缓存如果没有 Cache 组件自动创建 去 Cache 中查找缓存的内容，使用一个 key，默认就是方法的参数，key 是按照某种策略生成的，默认是keyGenerator生成的 没有查到缓存就调用目标方法 将目标方法返回的结果，放进缓存中","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot整合Mybatis-Plus","date":"2019-10-27T08:38:00.000Z","path":"2019/10/27/SpringBoot整合Mybatis-Plus/","text":"简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 快速入门定义 user表，表结构如下： id name age email manager_id create_time 1087982257332887553 大boss 40 boss@baomidou.com 2019-01-11 14:20:20 1088248166370832385 王天风 25 wtf@baomidou.com 1087982257332887553 2019-02-05 11:12:22 1088250446457389058 李艺伟 28 lyw@baomidou.com 1088248166370832385 2019-02-14 08:31:16 定义实体类 ： 1234567891011121314@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email; private Long managerId; private Date createTime;&#125; dao 接口，UserMapper，只需要继承 BaseMapper&lt;User&gt; 测试例子： 123456789101112131415@Slf4j@SpringBootTest@RunWith(SpringRunner.class)public class UserMapperTest &#123; @Autowired UserMapper userMapper; @Test public void testSelectAll()&#123; List&lt;User&gt; userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); &#125;&#125; 条件查询 名字包含雨并且年龄小于40 (name like ‘%雨%’ and age &lt; 40) 12345678@Test public void selectByWrapper()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(\"name\", \"雨\").lt(\"age\", 40); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 名字包含雨并且年龄大于等于20且小于等于40并且email不能为空 (name like ‘%雨%’ and age between 20 and 40 and email is not null) 1234567@Test public void selectByWrapper2()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(\"name\", \"雨\").between(\"age\", 20, 40).isNotNull(\"email\"); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 创建日期为2019/2/14并且直属上级名字为王姓 (date_formate(‘%Y-%M-%d’, date) and manager_id in (select manager_id from user where name like ‘王%’)) 12345678910@Test public void selectByWrapper4()&#123; Date date = new Date(2019, 2, 5); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper. apply(\"date_format(create_time,'%Y-%m-%d') = &#123;0&#125;\", \"2019-02-05\") .inSql(\"manager_id\", \"select manager_id from user where name like '王%'\"); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 按照直属上级分组，查询每组的平均年龄、最大年龄、最小年龄，并且只取年龄总和小于500的组 (select avg(age), max(age), min(age) from user group by manager_id having sum(age) &lt; 500) 123456789@Test public void selectByWrapper12()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(\"avg(age), max(age), min(age)\") .groupBy(\"manager_id\") .having(\"sum(age) &lt; &#123;0&#125;\", 500); List&lt;Map&lt;String, Object&gt;&gt; users = userMapper.selectMaps(queryWrapper); users.forEach(System.out::println); &#125; lambda 条件查询器 1234567@Test public void selectByWrapper13()&#123; LambdaQueryWrapper&lt;User&gt; lambdaQuery = Wrappers.lambdaQuery(); lambdaQuery.like(User::getName, \"雨\").lt(User::getAge, 40); List&lt;Map&lt;String, Object&gt;&gt; users = userMapper.selectMaps(lambdaQuery); users.forEach(System.out::println); &#125; 根据实体查询 123456789@Test public void selectByEntity()&#123; User user = new User(); user.setName(\"王天风\"); user.setAge(25); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(user); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125;","tags":[{"name":"Mybatis-Plus","slug":"Mybatis-Plus","permalink":"http://yoursite.com/tags/Mybatis-Plus/"}]},{"title":"SpringBoot整合Jpa","date":"2019-10-20T05:38:27.000Z","path":"2019/10/20/SpringBoot整合Jpa/","text":"表结构12345Hero Category Hero_Category------- ------- -------------id id hero_idname name cate_id superior 英雄表和分类表是多对多的关系，分类表里面的 superior为上级分类 id，superior 和 id 是一对多的关系。 实体对象1234567public class Hero &#123; @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinTable(name = \"orm_hero_cate\", joinColumns = @JoinColumn(name = \"hero_id\", referencedColumnName = \"id\"), inverseJoinColumns = @JoinColumn(name = \"cate_id\", referencedColumnName = \"id\")) private List&lt;Category&gt; categories;&#125; 1234567891011public class Category &#123; @ManyToOne(cascade = &#123;CascadeType.REFRESH, CascadeType.REMOVE&#125;, optional = true) @JoinColumn(name = \"superior\", referencedColumnName = \"id\") private Category superior; @ManyToMany(mappedBy = \"categories\") private List&lt;Hero&gt; heroes; @OneToMany(mappedBy=\"superior\") private List&lt;Category&gt; children;&#125; 相关说明： @JoinTable，表示通过第三张关联表来管理 hero 和 category，joinColumn，关联到主表的外键名，主表名+下划线+主表中的主键列名，即 hero_id。关联到从表的外键名，主表中用于关联的属性名+下划线+从表的主键列名，即cate_id。 主表就是关系维护端对应的表，从表就是关系被维护端对应的表 superior 和 id 是一对多的关系，@ManyToOne来表示 mapperBy表示关联的属性字段 测试代码 1234567891011121314151617181920212223242526@Test public void testSave()&#123; List&lt;Category&gt; categoryList = categoryDao.findByLevel(0); if (categoryList.size() == 0)&#123; Category testCate = Category.builder().name(\"testCate\").level(1).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_1 = Category.builder().name(\"testCate_1\").level(2).superior(testCate).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_2 = Category.builder().name(\"testCate_2\").level(2).superior(testCate).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); Category testCate_1_1 = Category.builder().name(\"testCate_1_1\").level(3).superior(testCate_1).createTime(new DateTime()).lastUpdateTime(new DateTime()).build(); categoryList.add(testCate); categoryList.add(testCate_1); categoryList.add(testCate_2); categoryList.add(testCate_1_1); categoryDao.saveAll(categoryList); List&lt;Category&gt; categories = categoryDao.findAll(); log.debug(\"【分类】=&#123;&#125;\", JSONArray.toJSONString(categories)); &#125; heroDao.findById(1).ifPresent(hero -&gt; &#123; hero.setCategories(categoryList); hero.setName(\"添加分类\"); heroDao.save(hero); &#125;); log.debug(\"【英雄分类】=&#123;&#125;\", JSONUtil.toJsonStr(heroDao.findById(1).get().getCategories())); &#125; 参考https://stackoverflow.com/questions/5478328/jpa-jointable-annotation https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-orm-jpa","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]}]